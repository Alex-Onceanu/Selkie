#version 460
#extension GL_EXT_ray_tracing : require

layout(set = 0, binding = 0) uniform accelerationStructureEXT bvh;
layout(set = 0, binding = 1, rgba8) uniform image2D image;

struct payload_t {
    float time;
    vec3 hitColor;
};

layout(location = 0) rayPayloadEXT payload_t payload;

layout(push_constant) uniform PushConstants {
    float mtime;
};

mat2 rot2D(float theta)
{
    return mat2(vec2(cos(theta), -sin(theta)), vec2(sin(theta), cos(theta)));
}

void main()
{
    vec2 uv = vec2(gl_LaunchIDEXT.xy) / vec2(gl_LaunchSizeEXT.xy);
    uv = 2. * uv - 1.;    // uv is in [-1, 1]
    uv.x *= 1366. / 768.; // aspect ratio
    uv.y = - uv.y;        // x goes right, y goes up, z towards me

    payload.time = mtime;

    float fov = 70.;
    fov *= 3.1416 / 180.;
    vec3 cameraPos = vec3(0., 1, 6.);
    vec3 rayDir = vec3(uv.x, uv.y, -2. / tan(0.5 * fov));
    cameraPos.xz *= rot2D(0.25 * payload.time);
    rayDir.xz *= rot2D(0.25 * payload.time);

    vec2 pxSize = 1. / vec2(gl_LaunchSizeEXT.xy);
#if 0
    vec3 off = vec3(length(pxSize) / 4., -length(pxSize) / 4., 0.); 

    // tlas, flags, mask, sbt offset, sbt stride, rmiss index, origin, tMin, dir, tMax, payloadLocation
    traceRayEXT(bvh, gl_RayFlagsNoneEXT, 0xFF, 0, 1, 0, cameraPos, 1., rayDir + off.xxz, 1. / 0., 0);
    vec3 c1 = payload.hitColor;
    traceRayEXT(bvh, gl_RayFlagsNoneEXT, 0xFF, 0, 1, 0, cameraPos, 1., rayDir + off.xyz, 1. / 0., 0);
    vec3 c2 = payload.hitColor;
    traceRayEXT(bvh, gl_RayFlagsNoneEXT, 0xFF, 0, 1, 0, cameraPos, 1., rayDir + off.yxz, 1. / 0., 0);
    vec3 c3 = payload.hitColor;
    traceRayEXT(bvh, gl_RayFlagsNoneEXT, 0xFF, 0, 1, 0, cameraPos, 1., rayDir + off.yyz, 1. / 0., 0);
    vec3 c4 = payload.hitColor;

    vec3 avg = 0.25 * (c1 + c2 + c3 + c4);

#elif 0
    vec3 avg = vec3(0.);

    for(int i = -1; i <= 1; i++)
    {
        for(int j = -1; j <= 1; j++)
        {
            vec3 off = vec3(i * pxSize.x / 4., j * pxSize.y / 4., 0.);
            // tlas, flags, mask, sbt offset, sbt stride, rmiss index, origin, tMin, dir, tMax, payloadLocation
            traceRayEXT(bvh, gl_RayFlagsNoneEXT, 0xFF, 0, 1, 0, cameraPos, 1., rayDir + off, 1. / 0., 0);
            avg += payload.hitColor;
        }
    }

    avg /= 9.;
#else
    traceRayEXT(bvh, gl_RayFlagsNoneEXT, 0xFF, 0, 1, 0, cameraPos, 1., rayDir, 1. / 0., 0);
    vec3 avg = payload.hitColor;
#endif

    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(avg, 0.0));
}
